/**
 * 给你一个整数数组 nums 和一个整数k ，请你统计并返回 该数组中和为k的子数组的个数。
 *
 * // :::: 子数组，的概念需要注意！！！
 *
 * 示例 1：
 *
 * 输入：nums = [1,1,1], k = 2
 * 输出：2
 *
 * 示例 2：
 * 输入：nums = [1,2,3], k = 3
 * 输出：2
 *
 * 示例 2：
 * 输入：nums = [1,2,3,1], k = 4
 * 输出：2
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode.cn/problems/subarray-sum-equals-k
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * */


/***********************
 * 1、转化为前缀和，注意第一项为0
 *  => 有几种 i、j 的组合，满足 pre[j] - pre[i - 1] == k
 *  => 举例：   [3, 5，2，-2, 4，1】
 *  => 举例：【0，3，8，10，8，12，13】
 *
 *
 * 其实我们不关心具体是哪两项的前缀和之差等于k，只关心等于 k 的前缀和之差出现的次数c，就知道了有c个子数组求和等于k。
 * 遍历 nums 之前，我们让 -1 对应的前缀和为 0，这样通式在边界情况也成立。即在遍历之前，map 初始放入 0:1 键值对（前缀和为0出现1次了）。
 * 遍历 nums 数组，求每一项的前缀和，统计对应的出现次数，以键值对存入 map。
 * 边存边查看 map，如果 map 中存在 key 为「当前前缀和 - k」 =>  pre[j]-k = pre[i-1]
 * =>  说明这个之前出现的前缀和，满足「当前前缀和 - 该前缀和 == k」，它出现的次数，累加给 count。
 *
 *
 *
 * 复盘总结
 * 每个元素对应一个“前缀和”
 * 遍历数组，根据当前“前缀和”，在 map 中寻找「与之相减 == k」的历史前缀和
 * 当前“前缀和”与历史前缀和，差分出一个子数组，该历史前缀和出现过 c 次，就表示当前项找到 c 个子数组求和等于 k。
 * 遍历过程中，c 不断加给 count，最后返回 count
 *
 *  空间复杂度：o(n)
 *  时间复杂度：o(n)
 * *******************/

function fn(nums, k) {
    const map = {0: 1};
    let pre = 0;
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        pre += nums[i];
        if (map[pre - k]) {
            count += map[pre - k];
        }
        if (map[pre]) {
            map[pre]++;
        } else {
            map[pre] = 1;
        }
    }
    return count;
}


/**


 * */

fn([1, 1, 1], 2)
fn([1, 2, 3], 3)
fn([1, 2, 3, 1], 6)
// =>[0,1,3,6,7]
